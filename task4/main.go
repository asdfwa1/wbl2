package main

func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
		//close(ch)
	}()
	for n := range ch {
		println(n)
	}
}

// программа выведет 0 1 2 3 4 5 6 7 8 9 all goroutines are sleep - deadlock. Так как в программе используется небуферезированный канал, то горунина-читатель ждет горутину-отправителя и наоборот, в этой программе горутина отправитель отправит 10 значений в канал и закончит свою работу, далее горутина читатель прочитает значения от 0 до 9 и будет продолжать ждать новые значения и в runtime обнаруживается, что горутина ждет = deadlock. Чтобы это избежать нужно закрыть канал, когда горутина отправитель выйдет из цикла или через defer.
